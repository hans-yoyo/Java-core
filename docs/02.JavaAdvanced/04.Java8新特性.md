# JDK8 新特性

[TOC]

## Default Methods for Interfaces(接口的默认方法)

Java8中接口可以申明默认方法(通过`default`关键字)和静态方法。

在Java8之前，接口中**只能**包含抽象方法。那么这有什么样弊端呢？比如，在一个接口中添加一个抽象方法，那么也就意味着之前实现该接口的所有实现类，都要重新实现这个方法才行。而接口的默认方法就是**为了解决接口的修改与接口实现类不兼容的问题，作为代码向前兼容的一个方法**。

```java
interface Formula {
    double calculate(int a);
    // 默认方法
    default double sqrt(int a) {
        return Math.sqrt(a);
    }
    // 静态方法
    static void staticMethod(){
        System.out.println("This is static Method in interface");
    }
}
```

除了抽象方法 `calculate` ，接口 `Formula` 还定义了默认方法 `sqrt`。具体类只需要执行抽象方法计算。默认的方法 `sqrt` 可以用于开箱即用。

```java
public static void main(String[] args) {
    Formula formula = new Formula() {
        @Override
        public double calculate(int a) {
            return sqrt(a * 100);
        }
    };
    System.out.println(formula.calculate(100));//100.0
    // 直接使用默认的sqrt方法
    System.out.println(formula.sqrt(64));//8.0

    Formula.staticMethod();
}
```

## Functional Interfaces(函数式接口)

Java8最大的变化是引入**了函数式思想，也就是说函数可以作为另一个函数的参数**。函数式接口，要求接口中**有且仅有一个抽象方法**，因此经常使用的Runnable，Callable接口就是典型的函数式接口。

可以使用`@FunctionalInterface`注解，声明一个接口是函数式接口。如果一个接口满足函数式接口的定义，会默认转换成函数式接口。但是，最好是使用`@FunctionalInterface`注解显式声明。这是因为函数式接口比较脆弱，如果开发人员无意间新增了其他方法，就破坏了函数式接口的要求，如果使用注解`@FunctionalInterface`，开发人员就会知道当前接口是函数式接口，就不会无意间破坏该接口。

示例：

```java
@java.lang.FunctionalInterface
public interface FunctionalInterface {

    void handle();

//    void play();

    default void run() {
        System.out.println("Run!");
    }

}
```

该接口只有一个抽象方法，并且使用注解显式声明, 如果去掉上面的`play()`的注释，编译器会报错。

函数式接口要求只有一个抽象方法，但是却可以拥有若干个默认方法的（实例方法）

## Lambda expressions(Lambda 表达式)

lambda表达式是函数式编程的核心，lambda表达式即匿名函数，是一段没有函数名的函数体，可以作为参数直接传递给相关的调用者。

- Lambda 表达式的应用则使代码变得更加紧凑，可读性增强

- Lambda 表达式使并行 操作大集合变得很方便，可以充分发挥多 核 CPU的优势，更易于为多核处理器编写代码

lambda的语法结构为：

```java
(parameters) -> expression
或
(parameters) ->{ statements; }

Lambda表达式由三部分组成:
第一部分为一个括号内用逗号分隔 的形式参数，参数是函数式接口里面方法的参数;
第二部分为一个箭 头符号: ->
第三部分为方法体，可以是表达式和代码块。
```

**可选类型声明**：不需要声明参数类型，编译器可以统一识别参数值。

**可选的参数圆括号**：一个参数无需定义圆括号，但多个参数需要定义圆括号。

**可选的大括号**：如果主体包含了一个语句，就不需要使用大括号。

**可选的返回关键字**：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指明表达式返回了一个数值。

```java
public class Java8Test {

    public static void main(String[] args) {
        Java8Test tester = new Java8Test();

        // 类型申明
        MathOperation addition = (int a, int b) -> a + b;

        // 等价于
        MathOperation add = new MathOperation() {
            @Override
            public int operation(int a, int b) {
                return a + b;
            }
        };

        // 省略类型申明
        MathOperation subtraction = (int a, int b) -> a - b;

        // 大括号中的返回语句
        MathOperation multiplication = (int a, int b) -> {
            return a * b;
        };

        // 没有大括号，返回语句
        MathOperation division = (int a, int b) -> a / b;

        System.out.println("10 + 5 = " + tester.operate(10, 5, addition));
        System.out.println("10 - 5 = " + tester.operate(10, 5, subtraction));
        System.out.println("10 x 5 = " + tester.operate(10, 5, multiplication));
        System.out.println("10 / 5 = " + tester.operate(10, 5, division));

        // 不用括号
        GreetingService greetService1 = message ->
                System.out.println("Hello " + message);

        // 用括号
        GreetingService greetService2 = (message) ->
                System.out.println("Hello " + message);

        greetService1.sayMessage("Runoob");
        greetService2.sayMessage("Google");

    }


    @java.lang.FunctionalInterface
    interface MathOperation {
        int operation(int a, int b);
    }

    @java.lang.FunctionalInterface
    interface GreetingService {
        void sayMessage(String message);
    }

    private int operate(int a, int b, MathOperation mathOperation) {
        return mathOperation.operation(a, b);
    }
}
```

集合排序演化过程

```java
List<String> names = Arrays.asList("peter", "anna", "mike", "xenia");

Collections.sort(names, new Comparator<String>() {
    @Override
    public int compare(String a, String b) {
        return b.compareTo(a);
    }
});
```

```java
Collections.sort(names, (String a, String b) -> {
    return b.compareTo(a);
});
```

```java
Collections.sort(names, (String a, String b) -> b.compareTo(a));
```

```java
names.sort((a, b) -> b.compareTo(a));
```

## Method and Constructor References(方法和构造器引用)

方法引用是为了进一步简化lambda表达式，通过类**名或者实例名与方法名的组合来直接访问到类或者实例已经存在的方法或者构造方法**。方法引用使用**::**来定义，**::**的前半部分表示类名或者实例名，后半部分表示方法名，如果是构造方法就使用`NEW`来表示。

方法引用在Java8中使用方式相当灵活，总的来说，一共有以下几种形式：

- 静态方法引用：ClassName::methodName;
- 实例上的实例方法引用：instanceName::methodName;
- 超类上的实例方法引用：supper::methodName;
- 类的实例方法引用：ClassName:methodName;
- 构造方法引用Class:new;
- 数组构造方法引用::TypeName[]::new

```java
public class MethodReferenceTest {

    public static void main(String[] args) {
        ArrayList<Car> cars = new ArrayList<>();
        for (int i = 0; i < 3; i++) {
            // 构造方法引用
            Car car = Car.create(Car::new);
            cars.add(car);
        }
        // 实例方法引用
        cars.forEach(Car::showCar);
    }

    @java.lang.FunctionalInterface
    interface Factory<T> {
        T create();
    }

    static class Car {
        public void showCar() {
            System.out.println(this.toString());
        }

        public static Car create(Factory<Car> factory) {
            return factory.create();
        }
    }

}

结果：
com.hyman.advance.jdk8.MethodReferenceTest$Car@568db2f2
com.hyman.advance.jdk8.MethodReferenceTest$Car@378bf509
com.hyman.advance.jdk8.MethodReferenceTest$Car@5fd0d5ae
```

在上面的例子中使用了`Car::new`，即通过构造方法的方法引用的方式进一步简化了lambda的表达式，`Car::showCar`，即表示实例方法引用。

## Lambda Scopes(Lambda 作用域)

从 lambda 表达式访问外部作用域变量与匿名对象非常相似。您可以访问本地外部作用域的常量以及实例的成员变量和静态变量。

### Accessing local variables(访问本地变量)

我们可以访问 lambda 表达式作用域外部的常量：

```java
final int num = 1;
Converter<Integer, String> stringConverter =
        (from) -> String.valueOf(from + num);

stringConverter.convert(2);     // 3
```

不同于匿名对象的是：这个变量 `num` 不是一定要被 `final` 修饰。下面的代码一样合法：

```java
int num = 1;
Converter<Integer, String> stringConverter =
        (from) -> String.valueOf(from + num);

stringConverter.convert(2);     // 3
```

但是，`num` 必须是隐式常量的。下面的代码不能编译通过：

```java
int num = 1;
Converter<Integer, String> stringConverter =
        (from) -> String.valueOf(from + num);
num = 3;
```

此外，在 lambda 表达式中对 `num` 做写操作也是被禁止的。

### Accessing fields and static variables(访问成员变量和静态变量)

与局部变量相比，我们既可以在 lambda 表达式中读写实例的成员变量，也可以读写实例的静态变量。这种行为在匿名对象中是众所周知的。

```java
class Lambda4 {
    static int outerStaticNum;
    int outerNum;

    void testScopes() {
        Converter<Integer, String> stringConverter1 = (from) -> {
            outerNum = 23;
            return String.valueOf(from);
        };

        Converter<Integer, String> stringConverter2 = (from) -> {
            outerStaticNum = 72;
            return String.valueOf(from);
        };
    }
}
```

### Accessing Default Interface Methods（访问默认的接口方法）

还记得第一节的 formula 例子吗？ `Formula` 接口定义了一个默认方法 `sqrt`，它可以被每个 formula 实例（包括匿名对象）访问。这个特性不适用于 lambda 表达式。

默认方法**不能**被 lambda 表达式访问。下面的代码不能编译通过：

```
Formula formula = (a) -> sqrt(a * 100);
```

## Built-in Functional Interfaces(内置函数接口)

JDK 1.8 API 包含许多内置的功能接口。它们中的一些在较早的 Java 版本（比如 `Comparator` 或 `Runnable`）中是众所周知的。这些现有的接口通过 `@FunctionalInterfaceannotation` 注解被扩展为支持 Lambda。

但是，Java 8 API 也提供了不少新的函数接口。其中一些新接口在 [Google Guava](https://code.google.com/p/guava-libraries/) 库中是众所周知的。即使您熟悉这个库，也应该密切关注如何通过一些有用的方法扩展来扩展这些接口。

### Predicates

`Predicate` 是只有一个参数的布尔值函数。该接口包含各种默认方法，用于将谓词组合成复杂的逻辑术语（与、或、非）

```java
Predicate<String> predicate = (s) -> s.length() > 0;

predicate.test("foo");              // true
predicate.negate().test("foo");     // false

Predicate<Boolean> nonNull = Objects::nonNull;
Predicate<Boolean> isNull = Objects::isNull;

Predicate<String> isEmpty = String::isEmpty;
Predicate<String> isNotEmpty = isEmpty.negate();
```

### Functions

`Function` 接受一个参数并产生一个结果。可以使用默认方法将多个函数链接在一起（compose、andThen）。

```java
Function<String, Integer> toInteger = Integer::valueOf;
Function<String, String> backToString = toInteger.andThen(String::valueOf);

backToString.apply("123");     // "123"
```

### Suppliers

`Supplier` 产生一个泛型结果。与 `Function` 不同，`Supplier` 不接受参数。

```java
Supplier<Person> personSupplier = Person::new;
personSupplier.get();   // new Person
```

### Consumers

Consumer 表示要在一个输入参数上执行的操作。

```java
Consumer<Person> greeter = (p) -> System.out.println("Hello, " + p.firstName);
greeter.accept(new Person("Luke", "Skywalker"));
```

### Comparators

比较器在老版本的 Java 中是众所周知的。 Java 8 为接口添加了各种默认方法。

```java
Comparator<Person> comparator = (p1, p2) -> p1.firstName.compareTo(p2.firstName);

Person p1 = new Person("John", "Doe");
Person p2 = new Person("Alice", "Wonderland");

comparator.compare(p1, p2);             // > 0
comparator.reversed().compare(p1, p2);  // < 0
```

## Optionals

为了解决空指针异常，在Java8之前需要使用if-else这样的语句去防止空指针异常，而在Java8就可以使用Optional来解决。Optional可以理解成一个数据容器，甚至可以封装null，并且如果值存在调用isPresent()方法会返回true。









`Optional` 不是功能性接口，而是防止 `NullPointerException` 的好工具。这是下一节的一个重要概念，所以让我们快速看看 `Optional` 是如何工作的。

可选是一个简单的容器，其值可以是 null 或非 null。想想一个可能返回一个非空结果的方法，但有时候什么都不返回。不是返回 null，而是返回 Java 8 中的 `Optional`。

```java
Optional<String> optional = Optional.of("bam");

optional.isPresent();           // true
optional.get();                 // "bam"
optional.orElse("fallback");    // "bam"

optional.ifPresent((s) -> System.out.println(s.charAt(0)));     // "b"
```

## Streams

Java8中有一种新的数据处理方式，那就是流Stream，结合lambda表达式能够更加简洁高效的处理数据。Stream使用一种类似于SQL语句从数据库查询数据的直观方式，对数据进行如筛选、排序以及聚合等多种操作。

### 什么是流Stream

Stream是**一个来自数据源的元素队列并支持聚合操作**，更像是一个更高版本的Iterator,原始版本的Iterator，只能一个个遍历元素并完成相应操作。而使用Stream，只需要指定什么操作，如“过滤长度大于10的字符串”等操作，Stream会内部遍历并完成指定操作。

Stream中的元素在管道中经过中间操作（intermediate operation）的处理后，最后由最终操作（terminal operation）得到最终的结果。

- 数据源：是Stream的来源，可以是集合、数组、I/O channel等转换而成的Stream；
- 基本操作：类似于SQL语句一样的操作，比如filter,map,reduce,find,match,sort等操作。

当我们操作一个流时，实际上会包含这样的执行过程：

**获取数据源-->转换成Stream-->执行操作，返回一个新的Stream-->再以新的Stream继续执行操作--->直至最后操作输出最终结果**。

### 生成Stream的方式

1. 从接口Collection中和Arrays：

- Collection.stream();
- Collection.parallelStream(); //相较于串行流，并行流能够大大提升执行效率
- Arrays.stream(T array);

2. Stream中的静态方法：

- Stream.of()；
- generate(Supplier s);
- iterate(T seed, UnaryOperator f);
- empty();

3. 其他方法

- Random.ints()
- BitSet.stream()
- Pattern.splitAsStream(java.lang.CharSequence)
- JarFile.stream()
- BufferedReader.lines()

```java
public static void main(String[] args) {
    // Stream的生成方式
    // 1.使用Collections和Arrays
    String[] strArr = new String[]{"a", "b", "c"};
    Stream<String> stream = Arrays.stream(strArr);
    List<String> list = Arrays.asList(strArr);
    Stream<String> stream1 = list.stream();

    // 2.使用Stream中提供的静态方法
    Stream<String> stream2 = Stream.of(strArr);
    Stream<Double> stream3 = Stream.generate(Math::random);
    Stream<Object> stream4 = Stream.empty();
    Stream.iterate(1, i -> i++);
}
```

### Stream的操作

常见的Stream操作有这样几种：

1. Intermediate（中间操作）:中间操作是指对流中数据元素做出相应转换或操作后依然返回为一个流Stream，仍然可以供下一次流操作使用。常用的有：map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip。
2. Termial（结束操作）：是指最终对Stream做出聚合操作，输出结果。







`java.util.Stream` 表示可以在其上执行一个或多个操作的元素序列。流操作是中间或终端。当终端操作返回一个特定类型的结果时，中间操作返回流本身，所以你可以链接多个方法调用。流在源上创建，例如一个 `java.util.Collection` 像列表或集合（不支持映射）。流操作既可以按顺序执行，也可以并行执行。

> 流是非常强大的，所以，我写了一个独立的 [Java 8 Streams 教程](http://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/) 。**您还应该查看 Sequent，将其作为 Web 的类似库。**

我们先来看看顺序流如何工作。首先，我们以字符串列表的形式创建一个示例源代码：

```java
List<String> stringCollection = new ArrayList<>();
stringCollection.add("ddd2");
stringCollection.add("aaa2");
stringCollection.add("bbb1");
stringCollection.add("aaa1");
stringCollection.add("bbb3");
stringCollection.add("ccc");
stringCollection.add("bbb2");
stringCollection.add("ddd1");
```

Java 8 中的集合已被扩展，可以通过调用 `Collection.stream()` 或`Collection.parallelStream()` 来简单地创建流。以下各节介绍最常见的流操作。

#### Filter

```java
// filter
streamList.stream()
    .filter(s -> s.startsWith("a"))
    .forEach(System.out::println);
System.out.println("======================");
streamList.forEach(System.out::println);

// streamList的值没有变化
```

#### Sorted

排序是一个中间操作，返回流的排序视图。元素按自然顺序排序，除非您传递自定义比较器。

```java
// sorted
Stream<Integer> stream5 = Stream.of(2, 3, 1, 5, 3, 2);
stream5.sorted(Integer::compareTo).forEach(System.out::println);
```

请记住，排序只会创建流的排序视图，而不会操纵支持的集合的排序。 `streamList` 的排序是不变的：

#### Map

> map：对Stream中元素按照指定规则映射成另一个元素

```java
streamList.stream()
    .map(String::toUpperCase)
    .map(a-> a+"_ZZZ")
    .sorted((a,b)->b.compareTo(a))
    .forEach(System.out::println);
```

map方法是一对一的关系，将stream中的每一个元素按照映射规则成另外一个元素，而如果是一对多的关系的话就需要使用flatmap方法。

#### Match

> match：检查流中元素是否匹配指定的匹配规则
>
> Stream 有三个 match 方法，从语义上说：
>
> - allMatch：Stream 中全部元素符合传入的 predicate，返回 true；
> - anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true；
> - noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true。

```java
boolean anyStartsWithA =
    stringCollection
        .stream()
        .anyMatch((s) -> s.startsWith("a"));

System.out.println(anyStartsWithA);      // true

boolean allStartsWithA =
    stringCollection
        .stream()
        .allMatch((s) -> s.startsWith("a"));

System.out.println(allStartsWithA);      // false

boolean noneStartsWithZ =
    stringCollection
        .stream()
        .noneMatch((s) -> s.startsWith("z"));

System.out.println(noneStartsWithZ);      // true
```

#### concat

> concat：对流进行合并操作

```java
Stream.concat(Stream.of(1,4,5), Stream.of(2,3,6,4))
    .forEach(System.out::print);
```

#### limit

> limit: 截取流中前几个的元素

```java
Stream<Integer> stream5 = Stream.of(2, 3, 1, 5);
stream5.limit(3).forEach(System.out::println);
```

#### distinct

> distinct: 对流中的数据去重

```java
Stream<Integer> stream5 = Stream.of(2, 3, 1, 5, 3, 2);
stream5.distinct().forEach(System.out::println);
```

#### skip

> skip: 跳过流中前几个数据

```java
Stream<Integer> stream5 = Stream.of(2, 3, 1, 5, 3, 2);
stream5.skip(2).forEach(System.out::println);
```

#### peek

> peek：对流中每一个元素依次进行操作，类似于forEach操作

```java
Stream.of("one", "two", "three", "four")
    .filter(e -> e.length() > 3)
    .peek(e -> System.out.println("Filtered value: " + e))
    .map(String::toUpperCase)
    .peek(e -> System.out.println("Mapped value: " + e))
    .collect(Collectors.toList());
```



<hr/>

以下为结束操作, 执行结束操作之后，流Stream就不可再次使用

#### Count

Count 是一个终端操作，返回流中元素的个数。

```java
long startsWithB =
    stringCollection
        .stream()
        .filter((s) -> s.startsWith("b"))
        .count();

System.out.println(startsWithB);    // 3
```

#### Max/Min

> max/min：找出流中最大或者最小的元素

```java
Stream<Integer> stream5 = Stream.of(2, 3, 1, 5);
Integer maxNum = stream5.max(Comparator.comparingInt(a -> a)).get();
// Integer maxNum = stream5.max(Integer::compareTo).get();
System.out.println(maxNum);
```

#### ForEach

> forEach用于遍历Stream中的所元素，避免了使用for循环，让代码更简洁，逻辑更清晰。

```java
Stream<Integer> stream5 = Stream.of(2, 3, 1, 5);
stream5.forEach(System.out::println);
```



#### Reduce

该终端操作使用给定的功能对流的元素进行缩减。结果是一个 `Optional` 持有缩小后的值。

```java
Optional<String> reduced =
    stringCollection
        .stream()
        .sorted()
        .reduce((s1, s2) -> s1 + "#" + s2);

reduced.ifPresent(System.out::println);
// "aaa1##aaa2##bbb1##bbb2##bbb3##ccc##ddd1##ddd2"
```

## Parallel Streams

如上所述，流可以是顺序的也可以是并行的。顺序流上的操作在单个线程上执行，而并行流上的操作在多个线程上同时执行。

以下示例演示了通过使用并行流提高性能是多么容易。

首先，我们创建一个较大的独特元素的列表：

```java
int max = 1000000;
List<String> values = new ArrayList<>(max);
for (int i = 0; i < max; i++) {
    UUID uuid = UUID.randomUUID();
    values.add(uuid.toString());
}
```

现在我们测量对这个集合进行排序所花费的时间。

### Sequential Sort

```java
long t0 = System.nanoTime();

long count = values.stream().sorted().count();
System.out.println(count);

long t1 = System.nanoTime();

long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);
System.out.println(String.format("sequential sort took: %d ms", millis));

// sequential sort took: 899 ms
```

### Parallel Sort

```java
long t0 = System.nanoTime();

long count = values.parallelStream().sorted().count();
System.out.println(count);

long t1 = System.nanoTime();

long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);
System.out.println(String.format("parallel sort took: %d ms", millis));

// parallel sort took: 472 ms
```

如你所见，两个代码段差不多，但是并行排序快了近 50%。你所需做的仅仅是将 `stream()` 改为 `parallelStream()` 。

## Maps

如前所述，map 不直接支持流。Map 接口本身没有可用的 `stream()` 方法，但是你可以通过 `map.keySet().stream()` 、 `map.values().stream()` 和 `map.entrySet().stream()` 创建指定的流。

此外，map 支持各种新的、有用的方法来处理常见任务。

```java
Map<Integer, String> map = new HashMap<>();

for (int i = 0; i < 10; i++) {
    map.putIfAbsent(i, "val" + i);
}

map.forEach((id, val) -> System.out.println(val));
```

上面的代码应该是自我解释的：`putIfAbsent` 阻止我们写入额外的空值检查；`forEach` 接受消费者为 map 的每个值实现操作。

这个例子展示了如何利用函数来计算 map 上的代码：

```java
map.computeIfPresent(3, (num, val) -> val + num);
map.get(3);             // val33

map.computeIfPresent(9, (num, val) -> null);
map.containsKey(9);     // false

map.computeIfAbsent(23, num -> "val" + num);
map.containsKey(23);    // true

map.computeIfAbsent(3, num -> "bam");
map.get(3);             // val33
```

接下来，我们学习如何删除给定键的条目，只有当前键映射到给定值时：

```java
map.remove(3, "val3");
map.get(3);             // val33

map.remove(3, "val33");
map.get(3);             // null
```

另一个有用方法：

```java
map.getOrDefault(42, "not found");  // not found
```

合并一个 map 的 entry 很简单：

```java
map.merge(9, "val9", (value, newValue) -> value.concat(newValue));
map.get(9);             // val9

map.merge(9, "concat", (value, newValue) -> value.concat(newValue));
map.get(9);             // val9concat
```

如果不存在该键的条目，合并或者将键/值放入 map 中；否则将调用合并函数来更改现有值。

## Date API

Java 8 在 `java.time` 包下新增了一个全新的日期和时间 API。新的日期 API 与 [Joda-Time](http://www.joda.org/joda-time/) 库相似，但不一样。以下示例涵盖了此新 API 的最重要部分。

### Clock

`Clock` 提供对当前日期和时间的访问。`Clock` 知道一个时区，可以使用它来代替 `System.currentTimeMillis()` ，获取从 **Unix EPOCH** 开始的以毫秒为单位的当前时间。时间线上的某一时刻也由类 `Instant` 表示。 Instants 可以用来创建遗留的 `java.util.Date` 对象。

```java
Clock clock = Clock.systemDefaultZone();
long millis = clock.millis();

Instant instant = clock.instant();
Date legacyDate = Date.from(instant);   // legacy java.util.Date
```

### Timezones

时区由 `ZoneId` 表示。他们可以很容易地通过静态工厂方法访问。时区定义了某一时刻和当地日期、时间之间转换的重要偏移量。

```java
System.out.println(ZoneId.getAvailableZoneIds());
// prints all available timezone ids

ZoneId zone1 = ZoneId.of("Europe/Berlin");
ZoneId zone2 = ZoneId.of("Brazil/East");
System.out.println(zone1.getRules());
System.out.println(zone2.getRules());

// ZoneRules[currentStandardOffset=+01:00]
// ZoneRules[currentStandardOffset=-03:00]
```

### LocalTime

`LocalTime` 代表没有时区的时间，例如晚上 10 点或 17:30:15。以下示例为上面定义的时区创建两个本地时间。然后我们比较两次，并计算两次之间的小时和分钟的差异。

```java
LocalTime now1 = LocalTime.now(zone1);
LocalTime now2 = LocalTime.now(zone2);

System.out.println(now1.isBefore(now2));  // false

long hoursBetween = ChronoUnit.HOURS.between(now1, now2);
long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);

System.out.println(hoursBetween);       // -3
System.out.println(minutesBetween);     // -239
```

`LocalTime` 带有各种工厂方法，以简化新实例的创建，包括解析时间字符串。

```java
LocalTime late = LocalTime.of(23, 59, 59);
System.out.println(late);       // 23:59:59

DateTimeFormatter germanFormatter =
    DateTimeFormatter
        .ofLocalizedTime(FormatStyle.SHORT)
        .withLocale(Locale.GERMAN);

LocalTime leetTime = LocalTime.parse("13:37", germanFormatter);
System.out.println(leetTime);   // 13:37
```

### LocalDate

`LocalDate` 表示不同的日期，例如：2014 年 3 月 11 日。它是不可变的，并且与 `LocalTime` 完全类似。该示例演示如何通过加减日、月或年来计算新日期。请记住，每个操作都会返回一个新的实例。

```
LocalDate today = LocalDate.now();
LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);
LocalDate yesterday = tomorrow.minusDays(2);

LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);
DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();
System.out.println(dayOfWeek);    // FRIDAY
```

从一个字符串中解析出 LocalDate 对象，和解析 LocalTime 一样的简单：

```
DateTimeFormatter germanFormatter =
    DateTimeFormatter
        .ofLocalizedDate(FormatStyle.MEDIUM)
        .withLocale(Locale.GERMAN);

LocalDate xmas = LocalDate.parse("24.12.2014", germanFormatter);
System.out.println(xmas);   // 2014-12-24
```

### LocalDateTime

LocalDateTime 表示日期时间。它将日期和时间组合成一个实例。 `LocalDateTime` 是不可变的，其作用类似于 `LocalTime` 和 `LocalDate`。我们可以利用方法去获取日期时间中某个单位的值。

```java
LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);

DayOfWeek dayOfWeek = sylvester.getDayOfWeek();
System.out.println(dayOfWeek);      // WEDNESDAY

Month month = sylvester.getMonth();
System.out.println(month);          // DECEMBER

long minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);
System.out.println(minuteOfDay);    // 1439
```

通过一个时区的附加信息可以转为一个实例。这个实例很容易转为`java.util.Date` 类型。

```java
Instant instant = sylvester
        .atZone(ZoneId.systemDefault())
        .toInstant();

Date legacyDate = Date.from(instant);
System.out.println(legacyDate);     // Wed Dec 31 23:59:59 CET 2014
```

日期时间的格式化类似于 Date 或 Time。我们可以使用自定义模式创建格式化程序，而不是使用预定义的格式。

```java
DateTimeFormatter formatter =
    DateTimeFormatter
        .ofPattern("MMM dd, yyyy - HH:mm");

LocalDateTime parsed = LocalDateTime.parse("Nov 03, 2014 - 07:13", formatter);
String string = formatter.format(parsed);
System.out.println(string);     // Nov 03, 2014 - 07:13
```

不同于 `java.text.NumberFormat` ， `DateTimeFormatter` 是不可变且**线程安全的** 。

更多关于日期格式化的内容可以参考[这里](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html).

## Annotations

Java 8 中的注释是可重复的。让我们直接看一个例子来解决这个问题。

首先，我们定义一个包含实际注释数组的外层注释：

```
@interface Hints {
    Hint[] value();
}

@Repeatable(Hints.class)
@interface Hint {
    String value();
}
```

Java8 允许我们通过使用 `@Repeatable` 注解来引入多个同类型的注解。

### Variant 1: 使用容器注解 (老套路)

```
@Hints({@Hint("hint1"), @Hint("hint2")})
class Person {}
```

### Variant 2: 使用 repeatable 注解 (新套路)

```
@Hint("hint1")
@Hint("hint2")
class Person {}
```

使用场景 2，Java 编译器隐式地设置了 `@Hints` 注解。

这对于通过反射来读取注解信息很重要。

```java
Hint hint = Person.class.getAnnotation(Hint.class);
System.out.println(hint);                   // null

Hints hints1 = Person.class.getAnnotation(Hints.class);
System.out.println(hints1.value().length);  // 2

Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);
System.out.println(hints2.length);          // 2
```

尽管，我门从没有在 Person 类上声明 `@Hints` 注解，但是仍可以通过`getAnnotation(Hints.class)` 读取它。然而，更便利的方式是 `getAnnotationsByType` ，它可以直接访问所有 `@Hint` 注解。

此外，Java 8 中的注释使用扩展了两个新的目标：

```java
@Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})
@interface MyAnnotation {}
```

## JDK8 升级常见问题

> JDK8 发布很久了，它提供了许多吸引人的新特性，能够提高编程效率。
>
> 如果是新的项目，使用 JDK8 当然是最好的选择。但是，对于一些老的项目，升级到 JDK8 则存在一些兼容性问题，是否升级需要酌情考虑。
>
> 近期，我在工作中遇到一个任务，将部门所有项目的 JDK 版本升级到 1.8 （老版本大多是 1.6）。在这个过程中，遇到一些问题点，并结合在网上看到的坑，在这里总结一下。

### Intellij 中的 JDK 环境设置

#### Settings

点击 **File > Settings > Java Compiler**

Project bytecode version 选择 1.8

点击 **File > Settings > Build Tools > Maven > Importing**

选择 JDK for importer 为 1.8

#### Projcet Settings

**Project SDK** 选择 1.8

#### Application

如果 web 应用的启动方式为 Application ，需要修改 JRE

点击 **Run/Debug Configurations > Configuration**

选择 JRE 为 1.8

### Linux 环境修改

#### 修改环境变量

修改 `/etc/profile` 中的 **JAVA_HOME**，设置 为 jdk8 所在路径。

修改后，执行 `source /etc/profile` 生效。

编译、发布脚本中如果有 `export JAVA_HOME` ，需要注意，需要使用 jdk8 的路径。

#### 修改 maven

settings.xml 中 profile 的激活条件如果是 jdk，需要修改一下 jdk 版本

```xml
<activation>
  <jdk>1.8</jdk> <!-- 修改为 1.8 -->
</activation>
```

#### 修改 server

修改 server 中的 javac 版本，以 resin 为例：

修改 resin 配置文件中的 javac 参数。

```xml
<javac compiler="internal" args="-source 1.8"/>
```

### sun.\* 包缺失问题

JDK8 不再提供 `sun.*` 包供开发者使用，因为这些接口不是公共接口，不能保证在所有 Java 兼容的平台上工作。

使用了这些 API 的程序如果要升级到 JDK 1.8 需要寻求替代方案。

虽然，也可以自己导入包含 `sun.*` 接口 jar 包到 classpath 目录，但这不是一个好的做法。

需要详细了解为什么不要使用 `sun.*` ，可以参考官方文档：[Why Developers Should Not Write Programs That Call 'sun' Packages](http://www.oracle.com/technetwork/java/faq-sun-packages-142232.html)

### 默认安全策略修改

升级后估计有些小伙伴在使用不安全算法时可能会发生错误，so，支持不安全算法还是有必要的

找到\$JAVA_HOME 下 `jre/lib/security/java.security` ，将禁用的算法设置为空：`jdk.certpath.disabledAlgorithms=` 。

### JVM 参数调整

在 jdk8 中，PermSize 相关的参数已经不被使用：

```
-XX:MaxPermSize=size

Sets the maximum permanent generation space size (in bytes). This option was deprecated in JDK 8, and superseded by the -XX:MaxMetaspaceSize option.

-XX:PermSize=size

Sets the space (in bytes) allocated to the permanent generation that triggers a garbage collection if it is exceeded. This option was deprecated un JDK 8, and superseded by the -XX:MetaspaceSize option.
```

JDK8 中再也没有 `PermGen` 了。其中的某些部分，如被 intern 的字符串，在 JDK7 中已经移到了普通堆里。**其余结构在 JDK8 中会被移到称作“Metaspace”的本机内存区中，该区域在默认情况下会自动生长，也会被垃圾回收。它有两个标记：MetaspaceSize 和 MaxMetaspaceSize。**

-XX:MetaspaceSize=size

> Sets the size of the allocated class metadata space that will trigger a garbage collection the first time it is exceeded. This threshold for a garbage collection is increased or decreased depending on the amount of metadata used. The default size depends on the platform.

-XX:MaxMetaspaceSize=size

> Sets the maximum amount of native memory that can be allocated for class metadata. By default, the size is not limited. The amount of metadata for an application depends on the application itself, other running applications, and the amount of memory available on the system.

以下示例显示如何将类类元数据的上限设置为 256 MB：

XX:MaxMetaspaceSize=256m

### 字节码问题

ASM 5.0 beta 开始支持 JDK8

**字节码错误**

```
Caused by: java.io.IOException: invalid constant type: 15
	at javassist.bytecode.ConstPool.readOne(ConstPool.java:1113)
```

- 查找组件用到了 mvel，mvel 为了提高效率进行了字节码优化，正好碰上 JDK8 死穴，所以需要升级。

```xml
<dependency>
  <groupId>org.mvel</groupId>
  <artifactId>mvel2</artifactId>
  <version>2.2.7.Final</version>
</dependency>
```

- javassist

```xml
<dependency>
  <groupId>org.javassist</groupId>
  <artifactId>javassist</artifactId>
  <version>3.18.1-GA</version>
</dependency>
```

> **注意**
>
> 有些部署工具不会删除旧版本 jar 包，所以可以尝试手动删除老版本 jar 包。

http://asm.ow2.org/history.html

### Java 连接 redis 启动报错 Error redis clients jedis HostAndPort cant resolve localhost address

错误环境:
本地 window 开发环境没有问题。上到 Linux 环境,启动出现问题。
错误信息:
Error redis clients jedis HostAndPort cant resolve localhost address

解决办法:

1. 查看 Linux 系统的主机名

```
# hostname
template
```

2. 查看/etc/hosts 文件中是否有 127.0.0.1 对应主机名，如果没有则添加

### Resin 容器指定 JDK 1.8

如果 resin 容器原来版本低于 JDK1.8，运行 JDK 1.8 编译的 web app 时，可能会提示错误：

```
java.lang.UnsupportedClassVersionError: PR/Sort : Unsupported major.minor version 52.0
```

解决方法就是，使用 JDK 1.8 要重新编译一下。然后，我在部署时出现过编译后仍报错的情况，重启一下服务器后，问题解决，不知是什么原因。

```
./configure --prefix=/usr/local/resin  --with-java=/usr/local/jdk1.8.0_121
make & make install
```

## 参考资料

- [java8-tutorial](https://github.com/winterbe/java8-tutorial)
- [Compatibility Guide for JDK 8](http://www.oracle.com/technetwork/java/javase/8-compatibility-guide-2156366.html)
- [Compatibility Guide for JDK 8 中文翻译](https://yq.aliyun.com/articles/236)
- [Why Developers Should Not Write Programs That Call 'sun' Packages](http://www.oracle.com/technetwork/java/faq-sun-packages-142232.html)
- [Java8新特性，你应该了解这些！](https://juejin.im/post/5ae6bfb66fb9a07a9b35bac1)
- [What's New in JDK 8](https://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html)
